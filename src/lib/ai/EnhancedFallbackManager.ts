/**
 * Enhanced Fallback Manager
 * Comprehensive fallback mechanisms and circuit breakers for AI provider failures
 */

interface ProviderHealth {
  status: 'healthy' | 'degraded' | 'unhealthy' | 'offline'
  lastChecked: number
  consecutiveFailures: number
  responseTime: number
  errorRate: number
  successRate: number
}

interface FallbackStrategy {
  primary: string
  secondary: string[]
  emergency: string
  maxRetries: number
  retryDelay: number
  circuitBreakerThreshold: number
  healthCheckInterval: number
}

interface CircuitBreakerState {
  state: 'closed' | 'open' | 'half-open'
  failureCount: number
  lastFailureTime: number
  nextAttemptTime: number
  successCount: number
}

interface FallbackRequest {
  prompt: string
  context?: any
  options?: any
  attemptCount: number
  startTime: number
  errors: Array<{
    provider: string
    error: string
    timestamp: number
  }>
}

export class EnhancedFallbackManager {
  private providerHealth = new Map<string, ProviderHealth>()
  private circuitBreakers = new Map<string, CircuitBreakerState>()
  private fallbackStrategies = new Map<string, FallbackStrategy>()
  private healthCheckTimers = new Map<string, NodeJS.Timeout>()

  constructor() {
    this.initializeFallbackStrategies()
    this.startHealthMonitoring()
  }

  /**
   * Execute request with comprehensive fallback handling
   */
  async executeWithFallback(\n    request: FallbackRequest,\n    executor: (provider: string) => Promise<any>\n  ): Promise<{\n    success: boolean\n    response?: any\n    finalProvider?: string\n    attemptHistory: Array<{\n      provider: string\n      success: boolean\n      error?: string\n      responseTime: number\n    }>\n    totalTime: number\n  }> {\n    const attemptHistory: Array<{\n      provider: string\n      success: boolean\n      error?: string\n      responseTime: number\n    }> = []\n\n    const strategy = this.getStrategy(request.context?.subject || 'default')\n    const providers = this.getOrderedProviders(strategy)\n\n    let lastError: Error | null = null\n\n    for (const provider of providers) {\n      // Skip if circuit breaker is open\n      if (this.isCircuitBreakerOpen(provider)) {\n        console.log(`Skipping ${provider} - circuit breaker open`)\n        continue\n      }\n\n      const attemptStartTime = Date.now()\n      \n      try {\n        console.log(`Attempting ${provider} (attempt ${request.attemptCount + 1})...`)\n        \n        const response = await this.executeWithTimeout(\n          () => executor(provider),\n          this.getTimeoutForProvider(provider)\n        )\n\n        const responseTime = Date.now() - attemptStartTime\n        \n        // Record successful attempt\n        attemptHistory.push({\n          provider,\n          success: true,\n          responseTime\n        })\n\n        // Update provider health positively\n        this.recordSuccess(provider, responseTime)\n        \n        // Reset circuit breaker on success\n        this.handleCircuitBreakerSuccess(provider)\n\n        return {\n          success: true,\n          response,\n          finalProvider: provider,\n          attemptHistory,\n          totalTime: Date.now() - request.startTime\n        }\n\n      } catch (error) {\n        const responseTime = Date.now() - attemptStartTime\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error'\n        \n        console.error(`${provider} failed:`, errorMessage)\n        \n        // Record failed attempt\n        attemptHistory.push({\n          provider,\n          success: false,\n          error: errorMessage,\n          responseTime\n        })\n\n        // Update provider health negatively\n        this.recordFailure(provider, errorMessage)\n        \n        // Handle circuit breaker\n        this.handleCircuitBreakerFailure(provider)\n        \n        lastError = error instanceof Error ? error : new Error(errorMessage)\n        \n        // Add delay before next attempt\n        if (providers.indexOf(provider) < providers.length - 1) {\n          await this.delay(strategy.retryDelay)\n        }\n      }\n    }\n\n    // All providers failed\n    return {\n      success: false,\n      attemptHistory,\n      totalTime: Date.now() - request.startTime\n    }\n  }\n\n  /**\n   * Get providers in fallback order\n   */\n  private getOrderedProviders(strategy: FallbackStrategy): string[] {\n    const providers = []\n    \n    // Add primary if healthy\n    if (this.isProviderHealthy(strategy.primary)) {\n      providers.push(strategy.primary)\n    }\n    \n    // Add healthy secondary providers\n    for (const provider of strategy.secondary) {\n      if (this.isProviderHealthy(provider) && !providers.includes(provider)) {\n        providers.push(provider)\n      }\n    }\n    \n    // Add primary back if not already included (for degraded but available cases)\n    if (!providers.includes(strategy.primary)) {\n      providers.push(strategy.primary)\n    }\n    \n    // Add emergency provider as last resort\n    if (!providers.includes(strategy.emergency)) {\n      providers.push(strategy.emergency)\n    }\n    \n    return providers\n  }\n\n  /**\n   * Check if provider is healthy enough for requests\n   */\n  private isProviderHealthy(provider: string): boolean {\n    const health = this.providerHealth.get(provider)\n    if (!health) return true // Unknown providers are assumed healthy initially\n    \n    return health.status !== 'offline' && health.successRate > 0.5\n  }\n\n  /**\n   * Circuit breaker management\n   */\n  private isCircuitBreakerOpen(provider: string): boolean {\n    const breaker = this.circuitBreakers.get(provider)\n    if (!breaker) return false\n    \n    const now = Date.now()\n    \n    switch (breaker.state) {\n      case 'open':\n        if (now >= breaker.nextAttemptTime) {\n          // Transition to half-open\n          breaker.state = 'half-open'\n          breaker.successCount = 0\n          console.log(`Circuit breaker ${provider}: open -> half-open`)\n          return false\n        }\n        return true\n        \n      case 'half-open':\n        return false\n        \n      case 'closed':\n      default:\n        return false\n    }\n  }\n\n  private handleCircuitBreakerFailure(provider: string): void {\n    let breaker = this.circuitBreakers.get(provider)\n    if (!breaker) {\n      breaker = {\n        state: 'closed',\n        failureCount: 0,\n        lastFailureTime: 0,\n        nextAttemptTime: 0,\n        successCount: 0\n      }\n      this.circuitBreakers.set(provider, breaker)\n    }\n    \n    const now = Date.now()\n    breaker.failureCount++\n    breaker.lastFailureTime = now\n    \n    const strategy = this.getStrategy('default')\n    \n    switch (breaker.state) {\n      case 'closed':\n        if (breaker.failureCount >= strategy.circuitBreakerThreshold) {\n          breaker.state = 'open'\n          breaker.nextAttemptTime = now + 60000 // 1 minute timeout\n          console.log(`Circuit breaker ${provider}: closed -> open`)\n        }\n        break\n        \n      case 'half-open':\n        breaker.state = 'open'\n        breaker.nextAttemptTime = now + 60000\n        console.log(`Circuit breaker ${provider}: half-open -> open`)\n        break\n    }\n  }\n\n  private handleCircuitBreakerSuccess(provider: string): void {\n    let breaker = this.circuitBreakers.get(provider)\n    if (!breaker) return\n    \n    switch (breaker.state) {\n      case 'half-open':\n        breaker.successCount++\n        if (breaker.successCount >= 3) {\n          breaker.state = 'closed'\n          breaker.failureCount = 0\n          console.log(`Circuit breaker ${provider}: half-open -> closed`)\n        }\n        break\n        \n      case 'closed':\n        breaker.failureCount = Math.max(0, breaker.failureCount - 1)\n        break\n    }\n  }\n\n  /**\n   * Provider health tracking\n   */\n  private recordSuccess(provider: string, responseTime: number): void {\n    let health = this.providerHealth.get(provider)\n    if (!health) {\n      health = {\n        status: 'healthy',\n        lastChecked: Date.now(),\n        consecutiveFailures: 0,\n        responseTime: responseTime,\n        errorRate: 0,\n        successRate: 1\n      }\n    } else {\n      health.consecutiveFailures = 0\n      health.responseTime = (health.responseTime * 0.7) + (responseTime * 0.3) // Moving average\n      health.successRate = Math.min(1, health.successRate + 0.1)\n      health.errorRate = Math.max(0, health.errorRate - 0.1)\n    }\n    \n    // Update status based on metrics\n    if (health.responseTime < 5000 && health.successRate > 0.9) {\n      health.status = 'healthy'\n    } else if (health.responseTime < 10000 && health.successRate > 0.7) {\n      health.status = 'degraded'\n    } else {\n      health.status = 'unhealthy'\n    }\n    \n    health.lastChecked = Date.now()\n    this.providerHealth.set(provider, health)\n  }\n\n  private recordFailure(provider: string, error: string): void {\n    let health = this.providerHealth.get(provider)\n    if (!health) {\n      health = {\n        status: 'unhealthy',\n        lastChecked: Date.now(),\n        consecutiveFailures: 1,\n        responseTime: 30000, // Assume slow on failure\n        errorRate: 1,\n        successRate: 0\n      }\n    } else {\n      health.consecutiveFailures++\n      health.errorRate = Math.min(1, health.errorRate + 0.2)\n      health.successRate = Math.max(0, health.successRate - 0.2)\n    }\n    \n    // Update status based on failures\n    if (health.consecutiveFailures >= 5) {\n      health.status = 'offline'\n    } else if (health.consecutiveFailures >= 3) {\n      health.status = 'unhealthy'\n    } else {\n      health.status = 'degraded'\n    }\n    \n    health.lastChecked = Date.now()\n    this.providerHealth.set(provider, health)\n  }\n\n  /**\n   * Execute with timeout\n   */\n  private async executeWithTimeout<T>(\n    fn: () => Promise<T>,\n    timeoutMs: number\n  ): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Request timeout after ${timeoutMs}ms`))\n      }, timeoutMs)\n      \n      fn()\n        .then(result => {\n          clearTimeout(timer)\n          resolve(result)\n        })\n        .catch(error => {\n          clearTimeout(timer)\n          reject(error)\n        })\n    })\n  }\n\n  /**\n   * Get timeout for specific provider\n   */\n  private getTimeoutForProvider(provider: string): number {\n    const health = this.providerHealth.get(provider)\n    const baseTimeout = 30000 // 30 seconds\n    \n    if (!health) return baseTimeout\n    \n    // Adjust timeout based on provider health\n    switch (health.status) {\n      case 'healthy':\n        return baseTimeout\n      case 'degraded':\n        return baseTimeout * 1.5\n      case 'unhealthy':\n        return baseTimeout * 2\n      case 'offline':\n        return baseTimeout * 0.5 // Fail fast for offline providers\n      default:\n        return baseTimeout\n    }\n  }\n\n  /**\n   * Initialize fallback strategies\n   */\n  private initializeFallbackStrategies(): void {\n    // Default strategy for general requests\n    this.fallbackStrategies.set('default', {\n      primary: 'anthropic',\n      secondary: ['openai', 'google'],\n      emergency: 'google',\n      maxRetries: 3,\n      retryDelay: 1000,\n      circuitBreakerThreshold: 5,\n      healthCheckInterval: 30000\n    })\n    \n    // Biology-specific strategy\n    this.fallbackStrategies.set('biology', {\n      primary: 'anthropic',\n      secondary: ['openai', 'google'],\n      emergency: 'openai',\n      maxRetries: 3,\n      retryDelay: 1500,\n      circuitBreakerThreshold: 3,\n      healthCheckInterval: 30000\n    })\n    \n    // Fast response strategy\n    this.fallbackStrategies.set('fast', {\n      primary: 'google',\n      secondary: ['openai', 'anthropic'],\n      emergency: 'openai',\n      maxRetries: 2,\n      retryDelay: 500,\n      circuitBreakerThreshold: 5,\n      healthCheckInterval: 15000\n    })\n    \n    // Critical request strategy\n    this.fallbackStrategies.set('critical', {\n      primary: 'anthropic',\n      secondary: ['openai', 'google'],\n      emergency: 'openai',\n      maxRetries: 5,\n      retryDelay: 2000,\n      circuitBreakerThreshold: 3,\n      healthCheckInterval: 10000\n    })\n  }\n\n  /**\n   * Get strategy for request type\n   */\n  private getStrategy(type: string): FallbackStrategy {\n    return this.fallbackStrategies.get(type) || this.fallbackStrategies.get('default')!\n  }\n\n  /**\n   * Health monitoring\n   */\n  private startHealthMonitoring(): void {\n    // Start health checks for each strategy\n    for (const [strategyName, strategy] of this.fallbackStrategies) {\n      const timer = setInterval(() => {\n        this.performHealthCheck(strategy)\n      }, strategy.healthCheckInterval)\n      \n      this.healthCheckTimers.set(strategyName, timer)\n    }\n    \n    console.log('Health monitoring started for all fallback strategies')\n  }\n\n  private async performHealthCheck(strategy: FallbackStrategy): Promise<void> {\n    const providers = [strategy.primary, ...strategy.secondary, strategy.emergency]\n    \n    for (const provider of providers) {\n      try {\n        const startTime = Date.now()\n        \n        // Simple health check - this would be replaced with actual API ping\n        await this.pingProvider(provider)\n        \n        const responseTime = Date.now() - startTime\n        this.recordHealthCheckSuccess(provider, responseTime)\n        \n      } catch (error) {\n        this.recordHealthCheckFailure(provider, error instanceof Error ? error.message : 'Health check failed')\n      }\n    }\n  }\n\n  private async pingProvider(provider: string): Promise<void> {\n    // Simplified health check - in reality this would make a minimal API call\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        // Simulate occasional failures for testing\n        if (Math.random() < 0.95) {\n          resolve()\n        } else {\n          reject(new Error('Health check failed'))\n        }\n      }, Math.random() * 1000)\n    })\n  }\n\n  private recordHealthCheckSuccess(provider: string, responseTime: number): void {\n    // Similar to recordSuccess but lighter weight for health checks\n    const health = this.providerHealth.get(provider)\n    if (health) {\n      health.lastChecked = Date.now()\n      health.responseTime = (health.responseTime * 0.9) + (responseTime * 0.1)\n      \n      if (health.status === 'offline' && health.consecutiveFailures > 0) {\n        health.consecutiveFailures = Math.max(0, health.consecutiveFailures - 1)\n        if (health.consecutiveFailures === 0) {\n          health.status = 'degraded'\n        }\n      }\n    }\n  }\n\n  private recordHealthCheckFailure(provider: string, error: string): void {\n    const health = this.providerHealth.get(provider)\n    if (health) {\n      health.lastChecked = Date.now()\n      health.consecutiveFailures++\n      \n      if (health.consecutiveFailures >= 10) {\n        health.status = 'offline'\n      }\n    }\n  }\n\n  /**\n   * Utility methods\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  /**\n   * Get current system status\n   */\n  getSystemStatus(): {\n    providers: Record<string, {\n      health: ProviderHealth\n      circuitBreaker: CircuitBreakerState\n    }>\n    strategies: Record<string, FallbackStrategy>\n    overallHealth: 'healthy' | 'degraded' | 'critical'\n  } {\n    const providers: Record<string, { health: ProviderHealth; circuitBreaker: CircuitBreakerState }> = {}\n    \n    // Collect all unique providers\n    const allProviders = new Set<string>()\n    for (const strategy of this.fallbackStrategies.values()) {\n      allProviders.add(strategy.primary)\n      strategy.secondary.forEach(p => allProviders.add(p))\n      allProviders.add(strategy.emergency)\n    }\n    \n    for (const provider of allProviders) {\n      const health = this.providerHealth.get(provider) || {\n        status: 'healthy' as const,\n        lastChecked: Date.now(),\n        consecutiveFailures: 0,\n        responseTime: 0,\n        errorRate: 0,\n        successRate: 1\n      }\n      \n      const circuitBreaker = this.circuitBreakers.get(provider) || {\n        state: 'closed' as const,\n        failureCount: 0,\n        lastFailureTime: 0,\n        nextAttemptTime: 0,\n        successCount: 0\n      }\n      \n      providers[provider] = { health, circuitBreaker }\n    }\n    \n    // Calculate overall health\n    const healthyProviders = Object.values(providers).filter(p => p.health.status === 'healthy').length\n    const totalProviders = Object.keys(providers).length\n    \n    let overallHealth: 'healthy' | 'degraded' | 'critical'\n    if (healthyProviders === totalProviders) {\n      overallHealth = 'healthy'\n    } else if (healthyProviders >= totalProviders / 2) {\n      overallHealth = 'degraded'\n    } else {\n      overallHealth = 'critical'\n    }\n    \n    return {\n      providers,\n      strategies: Object.fromEntries(this.fallbackStrategies),\n      overallHealth\n    }\n  }\n\n  /**\n   * Update fallback strategy\n   */\n  updateStrategy(name: string, strategy: Partial<FallbackStrategy>): void {\n    const existing = this.fallbackStrategies.get(name)\n    if (existing) {\n      this.fallbackStrategies.set(name, { ...existing, ...strategy })\n      console.log(`Updated fallback strategy: ${name}`)\n    }\n  }\n\n  /**\n   * Force circuit breaker state\n   */\n  forceCircuitBreakerState(provider: string, state: 'open' | 'closed'): void {\n    let breaker = this.circuitBreakers.get(provider)\n    if (!breaker) {\n      breaker = {\n        state: 'closed',\n        failureCount: 0,\n        lastFailureTime: 0,\n        nextAttemptTime: 0,\n        successCount: 0\n      }\n    }\n    \n    breaker.state = state\n    if (state === 'closed') {\n      breaker.failureCount = 0\n      breaker.successCount = 0\n    }\n    \n    this.circuitBreakers.set(provider, breaker)\n    console.log(`Forced circuit breaker ${provider} to ${state}`)\n  }\n\n  /**\n   * Cleanup\n   */\n  destroy(): void {\n    for (const timer of this.healthCheckTimers.values()) {\n      clearInterval(timer)\n    }\n    this.healthCheckTimers.clear()\n    console.log('Fallback manager destroyed')\n  }\n}\n\n// Export singleton instance\nexport const fallbackManager = new EnhancedFallbackManager()"